---
layout: post
title:  领域驱动架构的基本概念以及其基本的设计步骤
category: [DDD]
tags: [DDD]
modified: 2021-03-19
---
# DDD 基础概念01—领域模型—实体、值对象、聚合、聚合根

## 1.实体

- 有id
- user是实体

## 2.值对象 value object （VO）

- 实体具有唯一标识，而值对象没有唯一标识，这是实体和值对象间的最大不同。
- vo主要用于服务层，对bo进行拆分，使其使用代码逻辑的东西
- 关联信息，po持久化对象，和数据库表对应的对象，用于ORM
- po对象不能直接返回给前端，因为po查询出来的，type是数字需要转化成中文，比如某些字段还需要拼接

## 3.聚合及聚合根 aggregate、aggregate root

- 什么

  - 聚合，是定义领域对象的所有权和边界的<u>领域模式</u>。

- 作用

  - 是帮助简化模型对象间的关系。 
  - 通过定义对象间清晰的所属关系和边界来实现领域模型的内聚，避免错综复杂难以维护的对象关系网的形成。

- How？

  - 划分聚合是对领域模型的进一步深化，聚合能够阐释领域模型内部对象之间的深层关联，**<u>对聚合的划分回直接映射到程序结构上！</u>**
    - 比如：DDD推荐根据aggregation来设计model的子包，每个aggregation配备了一个repository.
    - aggregation内部的非root对象是根据导航获得的？？？—聚合根 非聚合根？


### 单独讲一讲聚合的特点*

1. 每个聚合都有一个根和一个边界（成分）

   1. 根是聚合内的某个实体
   2. 边界定义了聚合内部有哪些实体或值对象

2. 对于外部聚合根只有一个入口：聚合根（根的特点）

   1. 聚合内部的对象之间可以相互引用。
   2. 但是聚合外部如果需要访问聚合内部的对象时，必须统计难过聚合根开始导航， 绝对不饶过聚合根直接访问聚合内的对象，也就是说聚合根是外部可以保持对他的引用的唯一元素。（聚合之间访问，必须从根开始访问）
      1. 聚合根才能使用仓储直接查询，其他的职能通过相关的聚合访问。如果根实体被删除，聚合内部的其他对象也将被删除。（通过限制仓储、聚合访问的使用规范来达到上述目的）

3. 聚合内有自己的域空间：聚合根的id是global id，非根仅仅是local id（非根的特点）

   1. 非聚合根（其他实体）的唯一标识都是本地表示，仅在聚合内具有唯一性

      2. 这点很好理解，比如用户模块看作一个聚合，其中用户这个实体作为聚合根，其他实体，比如date of birth看作是辅助描述实体的属性，即值对象。那么dob作为非聚合根（根，即实体），则作为聚合内的local variable。
      2. 原因：因为一个聚合是一组相关的被称为整体的对象。每个聚合都有一个根对象（聚合根实体），从外部访问职能通过这个对象。根实体对象有组成聚合所有对象的引用，但是外部对象只能引用跟对象实体。

      

通常，我们把聚合组织到一个文件夹或一个包中。每一个聚集对应一个包，并且每个聚集成员包括实体、值对象，domain事件，仓储接口和其它工厂对象。

### 关于上述聚合特点的summary：**聚合是一个完整的概念，所以叫聚合**

  　　1. 每个聚合有一个根和一个边界，边界定义了一个聚合内部有哪些实体或值对象，根是聚合内的某个实体；

  　　2. 聚合内部的对象之间可以相互引用，但是聚合外部如果要访问聚合内部的对象时，必须通过聚合根开始导航，绝对不能绕过聚合根直接访问聚合内的对象，也就是说聚合根是外部可以保持对它的引用的唯一元素；

  　　3. 聚合内除根以外的其他实体的唯一标识都是本地标识，也就是只要在聚合内部保持唯一即可，因为它们总是从属于这个聚合的；

  　　4. 聚合根负责与外部其他对象打交道并维护自己内部的[业务规则](http://www.makaidong.com/search.jspx?q=业务规则)；

  　　5. 基于聚合的以上概念，我们可以推论出从[数据库](http://www.makaidong.com/search.jspx?q=数据库)查询时的单元也是以聚合为一个单元，也就是说我们不能直接查询聚合内部的某个非根的对象；

  　　6. 聚合内部的对象可以保持对其他聚合根的引用；

  　　7. 删除一个聚合根时必须同时删除该聚合内的所有相关对象，因为他们都同属于一个聚合，是一个**完整的概念**。

 

#### 如何**识别-聚合**？

1. 一致性

​    聚合中的对象关系是内聚的，即这些对象之间必须保持一个固定规则，固定规则是指在数据变化时必须保持不变的[一致性](http://www.makaidong.com/search.jspx?q=一致性)规则。

​    当我们在修改一个聚合时，我们必须在事务级别确保整个聚合内的所有对象满足这个固定规则。

​    作为一条建议，聚合尽量不要太大，否则即便能够做到在事务级别保持聚合的[业务规则](http://www.makaidong.com/search.jspx?q=业务规则)完整性，也可能会带来一定的性能问题。

​    有分析报告显示，通常在大部分领域模型中，**<u>有70%的聚合通常只有一个实体，即聚合根</u>**，该实体内部没有包含其他实体，只包含一些值对象；另外30%的聚合中，基本上也只包含两到三个实体。这意味着大部分的聚合都只是一个实体，该实体同时也是聚合根。

 

#### 如何**识别-聚合根**？

　　如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互。

​    并不是所有的实体都是聚集根，但只有实体才能成为聚集根。


## 4．工厂(factories)：

​    工厂用来封装创建一个复杂对象尤其是聚合时所需的知识，作用是将创建对象的细节隐藏起来。客户传递给工厂一些简单的参数，然后工厂可以在内部创建出一个复杂的领域对象然后返回给客户。当创建 实体和值对象复杂时建议使用工厂模式。

​    如果创建对象很简单，使用构造器或者控制反转/依赖注入容器足够创建对象的依赖。此时，我们就不需要通用工厂模式来创建实体或值对象。

​    良好工厂的要求：

​    每个创建方法都是原子的。一个工厂应该只能生产透明状态的对象。对于实体，意味着创建整个聚合时满足所有的不变量。

​    **一个单独的工厂通常生产整个聚合，传出一个根实体的引用**，确保聚合的**不变量**都有。<u>如果对象的内部聚合需要工厂，通常工厂方法的逻辑放在在聚合根上</u>。这样对外部隐藏了聚合内聚的实现，同时赋予了**根确保聚合完整的职责**。如果聚合根不是子实体工厂的合适的家，那么继续创建一个单独的工厂。



## 5．仓储（repositories）：**仓储里面存放的对象一定是聚合**

​    仓储是用来管理实体的集合。

​     **仓储里面存放的对象一定是聚合**，原因是domain是以聚合的概念来划分边界的；聚合作为一个整体概念，要么一起被取出来，要么一起被删除。外部访问不会单独对某个聚合内的子对象进行单独操作。因此，我们只对聚合设计仓储。

​     仓储还有一个重要的特征就是分为仓储定义部分和仓储实现部分，我们在领域模型中定义仓储的接口，而在基础设施层实现具体的仓储。也符合按照接口分离模式在领域层定义仓储库接口的原则。

​    注意：repositories本身是一种领域组件，但repositories的实现却不是领域层中的。

### respositories和dao：

  - dao和repository在领域驱动设计中都很重要。
    - dao是面向数据访问的，是关系型[数据库](http://www.makaidong.com/search.jspx?q=数据库)和应用之间的契约。
    - repository：位于领域层，面向aggregation root。
    - repository是一个独立的抽象，使用领域的通用语言，它与dao进行交互，并使用领域理解的语言提供对领域模型的数据访问服务的“业务接口”。
    - dao方法是**细粒度**的，更接近[数据库](http://www.makaidong.com/search.jspx?q=数据库)，而repository方法的粒度粗一些，而且更接近领域。领域对象应该只依赖于repository接口。
    - 调用顺序：
      - **客户端应该始终调用领域对象，领域对象再调用dao将数据持久化到数据存储中***

  　　处理领域对象之间的依赖关系（比如实体及其repository之间的依赖关系）是[开发人员](http://www.makaidong.com/search.jspx?q=开发人员)经常遇到的典型问题。为了解决这个问题，通常的设计方案是让服务类或外观类直接调用repository，在调用repository的时候返回实体对象给客户端。

## 6．服务（services）：

​     服务这个词在服务模式中是这么定义的：服务提供的操作是它提供给使用它的客户端，并突出领域对象的关系。

​     所有的service只负责协调并委派业务逻辑给领域对象进行处理，其本身并真正实现业务逻辑，绝大部分的业务逻辑都由领域对象承载和实现了。

​     service可与多种组件进行交互，这些组件包括：其他的service、领域对象和repository 或 dao。

​     通常，应用中一般包括：domain模型服务和应用层服务：

​    \* domain services encapsulate domain concepts that just are not naturally modeled as things.

​    \* application services constitute the application, or service, layer.

 

​    当一个领域操作被视为一个重要的领域概念，一般就应该作为**领域服务**。 服务应该是<u>**无状态**</u>的。

​    设计实现领域服务来协调业务逻辑，只在领域服务中实现领域逻辑的调用。

​    **领域服务逻辑须以非常干净简洁的代码实现**。因此，我们必须实现对领域低层组件的调用。通常应用的调用，例如仓储库的调用，创建事务等，不应该在这里实现。这些操作应该在应用层实现。

​     通常服务对象名称中都应包含一个动词。 **service接口的传入传出参数也都应该是dto**

- 可能包含的工作有**领域对象和dto的转换**以及事务。

 

   **服务的3个特征？**：

　　a. 服务执行的操作涉及一个领域概念，这个领域概念通常不属于一个实体或者值对象

　　b. 被执行的操作涉及到领域中其它的对象

　　c. 操作时无状态的

推荐：最好显式声明服务，因为它创建了领域中一个清晰的特性，封装了一个概念领域层服务和基础设施层服务：均建立在领域实体和值对象的上层，以便直接为这些相关的对象提供所需的服务；

 

领域服务与domain对象的区别

​    一般的领域对象都是有状态和行为的，而领域服务没有状态只有行为。需要强调的是领域服务是无状态的，它存在的意义就是协调领域对象共同完成某个操作，所有的状态还是都保存在相应的领域对象中。

   **常见错误**： 通常，对[开发人员](http://www.makaidong.com/search.jspx?q=开发人员)来说创建不应该存在的服务相当容易；要么在服务中包含了本应存在于领域对象中的领域逻辑，要么扮演了缺失的领域对象角色，而这些领域对象并没有作为模型的一部分去创建。

## 7．domain事件：

​    domain event模式最初由udi dahan提出，发表在自己的博客上：http://www.udidahan.com/2009/06/14/domain-events-salvation/

​    企业级[应用程序](http://www.makaidong.com/search.jspx?q=应用程序)事件大致可以分为三类：系统事件、应用事件和领域事件。领域事件的触发点在领域模型（domain model）中。它的作用是将领域对象从对repository或service的依赖中解脱出来，避免让领域对象对这些设施产生直接依赖。它的做法就是当领域对象的业务方法需要依赖到这些对象时就发出一个事件，这个事件会被相应的对象监听到并做出处理。

​    通过使用领域事件，我们可以实现领域模型对象状态的异步更新、外部系统接口的委托调用，以及通过事件派发机制实现系统集成。另外，领域事件本身具有自描述性。它不仅能够表述系统发生了什么事情，而且还能够描述发生事件的动机。

​     domain事件也用表进行存储。

## 8．DTO

​    dto- datatransfer object（数据传输对象）：dto在设计之初的主要考量是以粗粒度的[数据结构](http://www.makaidong.com/search.jspx?q=数据结构)减少[网络通信](http://www.makaidong.com/search.jspx?q=网络通信)并简化调用接口。 

## 领域驱动架构与n层[架构设计](http://www.makaidong.com/search.jspx?q=架构设计)

### 领域驱动架构

​    eric  evans的“领域驱动设计- 应对软件的复杂性“一书中描述和解释了建议的n层架构高层次的图：

![img](https://cdn.jsdelivr.net/gh/henggao98/imgbed/posts/79f0097dff8dbc97f0f8ad6d691e730b.png)

领域驱动架构：共有三层，UI，APP，Domain，基础，数错了，四层，哈哈哈。

1. user interface：

   1. 该层包含与其他系统/客户进行交互的接口与通信设施，在多数应用里，该层可能提供包括web services、rmi或rest等在内的一种或多种通信接口。该层主要由facade、dto和assembler三类组件构成，三类组件均是典型的j2ee模式。
   2. dto的作用最初主要是以粗粒度的[数据结构](http://www.makaidong.com/search.jspx?q=数据结构)减少[网络通信](http://www.makaidong.com/search.jspx?q=网络通信)并简化调用接口。在领域驱动设计中，采用dto模型，可以起到隐藏领域细节，帮助实现独立封闭的领域模型的作用。
   3. dto与领域对象之间的相互转换工作多由assembler承担，也有一些系统使用反射机制自动实现dto与领域对象之间的相互转换，如apache common beanutils。
   4. facade的用意在于为远程客户端提供粗粒度的调用接口。facade本身不处理任何的业务逻辑，它的主要工作就是将一个用户请求委派给一个或多个service进行处理，同时借助assembler将service传入或传出的领域对象转化为dto进行传输。

2. application：

   1. application层中主要组件就是service。这里需要注意的是，service的组织粒度和接口设计依据与传统transaction script风格的service是一致的，但是两者的实现却有质的区别。
   2. transaction script(事务脚本)的核心是过程，通过过程的调用来组织业务逻辑，业务逻辑在服务（service）层进行处理。大部分业务应用都可以被看成一系列事务。
   3. transaction script的特点是简单容易理解，面向过程设计。 如果应用相对简单，在应用的[生命周期](http://www.makaidong.com/search.jspx?q=生命周期)里不会有基础设施技术的改变，尤其是业务逻辑很少会变动，采用transaction script风格简单自然，性能良好，容易理解。
   4. transaction script的缺点在于，对于复杂的业务逻辑难以保持良好的设计，事务之间的冗余代码不断增多。应用架构容易出现“胖服务层”和“贫血的领域模型”。同时，service层积聚越来越多的业务逻辑，导致[可维护性](http://www.makaidong.com/search.jspx?q=可维护性)和扩展性变差
   5. 领域模型属于[面向对象](http://www.makaidong.com/search.jspx?q=面向对象)设计，领域模型具备自己的属性行为和状态，领域对象元素之间通过聚合配合解决实际业务应用。可复用，可维护，易扩展，可以采用合适的设计模型进行详细设计。缺点是相对复杂，要求设计人员有良好的抽象能力。
   6. transactionscript风格业务逻辑主要在service中实现，而在领域驱动设计的架构里，service只负责协调并委派业务逻辑给领域对象进行处理。因此，我们可以考察这一点来识别系统是transaction script架构还是domain model架构。在实践中，设计良好的领域设计架构在[开发过程](http://www.makaidong.com/search.jspx?q=开发过程)中也容易向transaction script架构演变。

3. domain：

4. domain层是整个系统的核心层，该层维护一个使用[面向对象](http://www.makaidong.com/search.jspx?q=面向对象)技术实现的领域模型，几乎全部的业务逻辑会在该层实现。domain层包含entity（实体）、valueobject(值对象)、domain event（领域事件）和repository（仓储）等多种重要的领域组件。

5. infrastructure：

   1. infrastructure（基础设施层）为interfaces、application和domain三层提供支撑。所有与具体平台、框架相关的实现会在infrastructure中提供，避免三层特别是domain层掺杂进这些实现，从而“污染”领域模型。infrastructure中最常见的一类设施是对象持久化的具体实现。

### [n层架构设计](http://www.makaidong.com/search.jspx?q=架构设计)

   1. 层（layers）

   - 被视为构成应用或服务的水平堆叠的一组逻辑上的组件。它们帮助区分完成不同任务的组件，提供一个最大化复用和[可维护性](http://www.makaidong.com/search.jspx?q=可维护性)的设计。简言之，是关于在架构方面应用关注点分离的原则。     在传统的多层架构中，每个解决方案的组件必须分隔到不同的层。每层的组件必须内聚而且有大约相同的抽象级别。每个一级层应该和其他的一级层松耦合。从最底层的抽象级别看，例如第1层。这是系统的基础层。这些抽象的步骤是一步一步的最后到最顶层。多层应用的关键在于对依赖的管理。传统的多层架构，层内的组件只能和同级或者低级层的组件交互。这有利于减少不同层内组件的依赖。通常有**两种多层架构的设计方法**：严格和灵活的。     
     1. “严格的层设计” 
        1. 限定层内的组件只能和同一层、或者下一层的组件通信。即第n层只能和第n-1层交互，n-1层只能和n-2层交互，等等。
     2. “灵活的层设计”
        1. 允许层内的组件和任何低级别层交互。这种设计中，第n层可以和n-1，n-2层交互。
        2. 这种设计由于不需要对其他层进行重复的调用，从而可以提高性能。然而，这种设计不提供层之间的同层隔离级别，使得它难以在不影响多个高级层的时候替换一个低级的层。
        3. 由于层之间是通过定义明确的接口进行交互这一事实，很容易为各层添加替代的实现(例如 mock  and stubs)。
        4. 因为高层的组件只能和底层的交互，在单独的组件上进行测试是很容易的。

   - 使用层的好处 -  功能容易确定位置，解决方案也就容易维护。层内高内聚，层间松耦合使得维护/组合层更容易。 -  其他的解决方案可以重用由不同层暴露的功能。 -  当项目按逻辑分层时，分布式的部署更容易实现。 -  把层分布到不同的物理层可以提高可伸缩性；然后这一步应该进行仔细的评估，因为可能对性能带来负面影响。
   - 面向领域架构的分层：在面向领域架构中，关键是要清楚界定和分离**领域模型层**和**其他层**。

 领域驱动与项目开发

​     一般适合结合使用scrum(适用于[项目管理](http://www.makaidong.com/search.jspx?q=项目管理))和xp（适用于[软件开发](http://www.makaidong.com/search.jspx?q=软件开发)目标）方法对处理ddd实施项目。敏捷方法注重于交付商业价值，而ddd侧重于结合[软件系统](http://www.makaidong.com/search.jspx?q=软件系统)和业务模型。此 外，就ddd迭代的特性来说，scrum或dsdm这样的敏捷方法对[项目管理](http://www.makaidong.com/search.jspx?q=项目管理)来说也是更好的框架。

​    ddd迭代周期的[项目管理](http://www.makaidong.com/search.jspx?q=项目管理)模型如图所示。

![c8c31fbd9c14974794bf243163270f6a.png](/Users/gh/Downloads/c8c31fbd9c14974794bf243163270f6a.png.gif)



本图根据《domain driven design and development in practice》一文中插图进行了部分修改。

　　领域建模结束时可以开始领域驱动设计。关于如何开始实现领域对象模型，ramnivas laddad推荐如下的步骤。他强调要更侧重于领域模型中的领域对象，而不是服务。

​    \*  从领域实体和领域逻辑开始。

​    \*  不要一开始就从服务层开始，只添加那些逻辑不属于任何领域实体或值对象的服务。

​    \*  利用通用语言、契约式设计（dbc）、[自动化](http://www.makaidong.com/search.jspx?q=自动化)测试、 ci和重构，使实现尽可能地与领域模型紧密结合。

 

### 设计领域模型的一般步骤：

1. 根据需求建立一个初步的领域模型，识别出一些明显的领域概念以及它们的关联，关联可以暂时没有方向但需要有（1：1，1：n，m：n）这些关系；可以用文字精确的没有歧义的描述出每个领域概念的涵义以及包含的主要信息；

2. 分析主要的软件[应用程序](http://www.makaidong.com/search.jspx?q=应用程序)功能，识别出主要的应用层的类；这样有助于及早发现哪些是应用层的职责，哪些是领域层的职责；

3. 进一步分析领域模型，识别出哪些是实体，哪些是值对象，哪些是领域服务；

4. 分析关联，通过对业务的更深入分析以及各种[软件设计](http://www.makaidong.com/search.jspx?q=软件设计)原则及性能方面的权衡，明确关联的方向或者去掉一些不需要的关联；

5. **找出聚合边界及聚合根**，这是一件很有难度的事情；因为你在分析的过程中往往会碰到很多模棱两可的难以清晰判断的选择问题，所以，需要我们平时一些分析经验的积累才能找出正确的聚合根；

6. 为聚合根配备仓储，一般情况下是为一个聚合分配一个仓储，此时**只要设计好仓储的接口**即可；

7. 走查场景，确定我们设计的领域模型能够有效地解决[业务需求](http://www.makaidong.com/search.jspx?q=业务需求)；

8. 考虑如何**创建领域实体或值对象**，是通过工厂还是直接通过构造函数；

9. 停下来**重构模型**。寻找模型中觉得有些疑问或者是蹩脚的地方，比如思考一些对象应该通过关联导航得到还是应该从仓储获取？聚合设计的是否正确？考虑模型的性能怎样，等等；

​     领域建模是一个不断重构，持续完善模型的过程，大家会在讨论中将变化的部分反映到模型中，从而是模型不断细化并朝正确的方向走。

 

### 从设计和实现的角度来看，典型的ddd框架应该支持以下特征。

​    \*  应该是一个以pojo为基础的架构。

​    \*  应该支持使用ddd概念的业务领域模型的设计和实现。

​    \*  应该支持像依赖注入（di）和面向方向编程（aop）这些概念的开箱即用。

​    \*  与[单元测试](http://www.makaidong.com/search.jspx?q=单元测试)框架整合。

​    \*  与其它java/java ee框架进行良好的集成，比如jpa、hibernate、toplink等。

 一些反模式：

​    \*  贫血的领域对象

​    \*  重复的dao

​    \*  肥服务层：服务类在这里最终会包含所有的业务逻辑。

​    \*  依恋情结（feature envy）：函数对某个类的兴趣高过对自己所处类的兴趣。

 

## 一些思考

1. 建立完整自封闭的领域模型。

​    领域驱动架构相对比较容易理解，但建立一个完整自封闭的领域模型却很困难。“领域模型”是一个针对业务逻辑抽象的分析模型，它反映出对领域问题的整体描述。领域模型不是编程的实现模型，而是一组抽象概念的集合。一个领域概念不一定映射成一个类，也有可能会映射很多的类（包括多个实体或值对象）。领域需求的最初细节，在功能层面通过领域专家的讨论得出。领域专家并不一定需要熟知[软件开发](http://www.makaidong.com/search.jspx?q=软件开发)领域的知识，相反强调的是具有领域中的相关知识。领域需求在相互讨论中不断得到细化，还有可能在[开发过程](http://www.makaidong.com/search.jspx?q=开发过程)出现需求的反复或变更，这都要求领域模型的建立完善是一个反复重构的过程。[敏捷开发](http://www.makaidong.com/search.jspx?q=敏捷开发)是一种应对快速变化的需求的一种[软件开发](http://www.makaidong.com/search.jspx?q=软件开发)能力。强调[程序员](http://www.makaidong.com/search.jspx?q=程序员)团队与业务专家之间的紧密协作、面对面的沟通（认为比书面的文档更有效）、频繁交付新的软件版本、紧凑而自我组织型的团队、能够很好地适应需求变化的代码编写和团队组织方法。故采用[敏捷开发](http://www.makaidong.com/search.jspx?q=敏捷开发)有利于领域模型的建立完善，以更能符合用户的实际需求。

   关于领域模型分析存在有多种分析方法。也许并不是能经常能有机会去实践这些分析方法或分析领域模型。但关于领域驱动架构的理解，有助于帮助我们去理解领域驱动的设计，实现一些高内聚、低耦合的代码实现。

 

2. 领域服务建模

​     建立和识别领域服务也比较容易出错。通常的ssh分层架构与领域驱动架构相近，而ssh架构开发更容易导致transaction script架构而非领域驱动架构。在ssh分层架构上，[开发人员](http://www.makaidong.com/search.jspx?q=开发人员)更容易建立”贫血”模型，而在service里实现业务逻辑。而ddd强调“充血模型”，“薄”service层。建立领域服务需要识别出领域业务逻辑，并将业务实现到领域模型中。一方面，[业务需求](http://www.makaidong.com/search.jspx?q=业务需求)充满着变化，在[开发过程](http://www.makaidong.com/search.jspx?q=开发过程)中难以把握。当业务不明需求不清时，“贫血模型”就更容易被人接受。另一方面，在构建领域模型时，orm映射显示十分重要并且也非常复杂，包括类继承体系与[数据库](http://www.makaidong.com/search.jspx?q=数据库)的映射，抓取策略和缓存管理在内的一系列问题等．“贫血模型”有时会简化这种映射关系，同时，在处理对象依赖关系上显得更加灵活性。而领域模型强调了领域边界，对领域对象的访问总是通过聚合根开始，在有时候，模型的某些遍历会带来更大的性能和稳定性上的问题。而解决这些问题时，又常常会从实效性上出发而牺牲模型个别的清晰性和纯洁性。

 

3．领域对象、领域服务以及repository之间的互相依赖

​    在实际开发中，[开发人员](http://www.makaidong.com/search.jspx?q=开发人员)会经常需要处理领域对象之间的依赖关系，以及领域对象与repository间的依赖。通常可能的方案是让service或façade直接调用repository，从而获得返回的领域对象。这种方式导致各层间的依赖，通常我们应该考虑解耦这种依赖。当前实现组件解耦常用的技术无非是：控制反转(ioc)、依赖注入(di)、面向方面编程（aop）以及分布式服务接口。因此，解决依赖的一种思路利用di或aop将repository和服务注入到领域对象中。spring框架提供了相关的机制。在spring环境中，利用spring实例化对象，注入依赖，将服务、repository等领域对象联系起来。



CSDN原文链接：https://blog.csdn.net/qq_32109957/article/details/114358667